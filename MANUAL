MANUAL									-*- Outline -*-


* R5RS deviations

** Possibly unintuitive non-deviations
*** Argument-count is not checked 
*** Access to unbound variables returns `undefined'
*** no exactness property of numbers
**** (eq? 1 1.0) => #t
*** eq? will also work for strings

** Bugs

*** eq? comparison of primitives will fail
*** clustering (CPS) will break use of continuations over toplevel forms

** non-integral string/vector indices are not checked and return undefined result

* Extensions

** Special forms

  (%check (CLASS) X)
  (%check TYPE X)
  (%check X)
  (%code STRING-OR-SYMBOL ...)
  (%continue X ...)
  (%dispatch LAMDBA ... X)
  (%host-ref NAME ...)
  (%host-set! NAME X)
  (%inline (NUM-OR-OP ...) X ...)
  (%inline .NAME X ...)
  (%inline NAME X ...)
  (%loop LLIST X)
  (%native-lambda STRING ...)
  (%new CLASS X ...)
  (%property-ref NAME [X])
  (%property-set! NAME X Y)
  (%syntax-error MSG [X])
  (%void)

** Unimplemented standard procedures

  denominator
  eval
  imag-part
  make-polar
  make-rectangular
  numerator
  rationalize
  real-part
  transcript-off
  transcript-on

** Non-standard procedures

*** Implemented

  (% SYMBOL VALUE ...)
  (bind-method JSFUNC OBJECT)
  (callback PROC)
  (callback-method PROC)
  (compl PROC)
  (const X)
  (current-error-port)
  (exit CODE)
  (file-exists? STRING)
  (id X)
  (jstring X)
  (milliseconds [THUNK])
  (native JSFUNC)
  (native-method JSFUNC)
  (o PROC ...)
  (print X ...)
  (resume STATE)
  (suspend PROC)
  (void ...)
  (void? X)
  (with-input-from-port PORT THUNK)
  (with-output-to-port PORT THUNK)

** Extensions

  (substring STRING I [J])
  (string-fill! STRING CHAR [I [J]])
  (vector-fill! VECTOR X [I [J]])
  (load STRING [K])                               asynchronous!

  `for-each' and `map' accept a single vector.
  `apply' accepts a vector as last argument.

** Non-standard syntax

  (begin1 X1 X2 ...)
  (bind STRING ...)
  (fluid-let ((ID1 X1) ...) BODY ...)
  (when X1 BODY ...)
  (unless X1 BODY ...)
  (cut ...)
  (cond-expand CLAUSE ...)
  (define-syntax-rule (NAME ARG ...) BODY)
  (new CLASS ARG ...)
  (define-library-section NAME CLAUSE ...)        used internally
  (define-native NAME ...)
  (define-native-method NAME ...)
  (define-entry-point NAME EXP)
  (define-entry-point (NAME . LLIST) BODY ...)

** Special identifiers

  .NAME            ==>   (%property-ref "NAME")
  .NAME1.NAME2     ==>   (%property-ref "NAME1.NAME2")
  NAME1.NAME2      ==>   (%host-ref "NAME1.NAME2")
  NAME.            ==>   (%host-ref "NAME")

  (set! NAME1.NAME2 X)   ==>   (%host-set! "NAME1.NAME2" X)
  (set! NAME1. X)        ==>   (%host-set! "NAME1" X)
  (set! (.NAME X) Y)     ==>   (%property-set! "NAME" X Y)
  (set! (.NAME1.NAME2 X) Y)     ==>   (%property-set! "NAME1.NAME2" X Y)
